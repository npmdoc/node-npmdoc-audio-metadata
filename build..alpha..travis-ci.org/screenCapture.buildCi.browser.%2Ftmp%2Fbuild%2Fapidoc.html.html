<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/tmont/audio-metadata">audio-metadata (v0.3.0)</a>
</h1>
<h4>Extract metadata from audio files</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.audio-metadata">module audio-metadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.id3v1">
            function <span class="apidocSignatureSpan">audio-metadata.</span>id3v1
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.id3v2">
            function <span class="apidocSignatureSpan">audio-metadata.</span>id3v2
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.ogg">
            function <span class="apidocSignatureSpan">audio-metadata.</span>ogg
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">audio-metadata.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">audio-metadata.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.audio-metadata.index">module audio-metadata.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.index.id3v1">
            function <span class="apidocSignatureSpan">audio-metadata.index.</span>id3v1
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.index.id3v2">
            function <span class="apidocSignatureSpan">audio-metadata.index.</span>id3v2
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.index.ogg">
            function <span class="apidocSignatureSpan">audio-metadata.index.</span>ogg
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.audio-metadata.utils">module audio-metadata.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.utils.createView">
            function <span class="apidocSignatureSpan">audio-metadata.utils.</span>createView
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.utils.readAscii">
            function <span class="apidocSignatureSpan">audio-metadata.utils.</span>readAscii
            <span class="apidocSignatureSpan">(view, offset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.utils.readBytes">
            function <span class="apidocSignatureSpan">audio-metadata.utils.</span>readBytes
            <span class="apidocSignatureSpan">(view, offset, length, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.utils.readUtf8">
            function <span class="apidocSignatureSpan">audio-metadata.utils.</span>readUtf8
            <span class="apidocSignatureSpan">(view, offset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.audio-metadata.utils.trimNull">
            function <span class="apidocSignatureSpan">audio-metadata.utils.</span>trimNull
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.audio-metadata" id="apidoc.module.audio-metadata">module audio-metadata</a></h1>


    <h2>
        <a href="#apidoc.element.audio-metadata.id3v1" id="apidoc.element.audio-metadata.id3v1">
        function <span class="apidocSignatureSpan">audio-metadata.</span>id3v1
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id3v1 = function (buffer) {
	//read last 128 bytes
	var view = utils.createView(buffer);
	if (!checkMagicId3v1(view)) {
		return null;
	}

	function trim(value) {
		return value.replace(/[\s\u0000]+$/, '');
	}

	try {
		var offset = view.byteLength - 128 + 3,
			readAscii = utils.readAscii;
		var title = readAscii(view, offset, 30),
			artist = readAscii(view, offset + 30, 30),
			album = readAscii(view, offset + 60, 30),
			year = readAscii(view, offset + 90, 4);

		offset += 94;

		var comment = readAscii(view, offset, 28),
			track = null;
		offset += 28;
		if (view.getUint8(offset) === 0) {
			//next byte is the track
			track = view.getUint8(offset + 1);
		} else {
			comment += readAscii(view, offset, 2);
		}

		offset += 2;
		var genre = view.getUint8(offset);
		return {
			title: trim(title),
			artist: trim(artist),
			album: trim(album),
			year: trim(year),
			comment: trim(comment),
			track: track,
			genre: genre
		};
	} catch (e) {
		return null;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "tmont",
    "email": "tommy.mont@gmail.com"
  }
],
"name": "audio-metadata",
"optionalDependencies": {},
"readme": "# audio-metadata\n\n[![Build Status](https://travis-ci.org/tmont/audio-metadata.png)](https://travis-ci
.org/tmont/audio-metadata)\n[![NPM version](https://badge.fury.io/js/audio-metadata.png)](http://badge.fury.io/js/audio-metadata)\n\nThis is a tinyish (2.1K gzipped) library to extract metadata from audio files.\nSpecifically, it can extract [ID3v1](http://en.wikipedia.org/wiki/ID3#ID3v1),\n[ID3v2](http://en.wikipedia.org/wiki/ID3#ID3v2) and\n[Vorbis comments](http://www.xiph.org/vorbis/doc/v-comment.html)\n(i.e. metadata in [OGG containers](http://en.wikipedia.org/wiki/Ogg)).\n\nLicensed under the [WTFPL](http://www.wtfpl.net/).\n\n## What is this good for?\nThe purpose of this library is to be very fast and small. It's suitable\nfor server-side or client-side. Really any platform that supports\n`ArrayBuffer` and its ilk (`Uint8Array`, etc.).\n\nI wrote it because the other libraries were large and very robust; I just\nneeded something that could extract the metadata out without requiring\n30KB of JavaScript. `audio-metadata.min.js` comes in at 6.1K/2.1K\nminified/gzipped.\n\nTo accomplish the small size and speed, it sacrifices several things.\n\n1. It's very naive. For example, the OGG format stipulates that the comment\n   header must come second, after the identification header. This library\n   assumes that's always true and ignores the header type byte.\n2. Text encoding is for losers. ID3v2 in particular has a lot of flexibility in\n   terms of the encoding of text for ID3 frames. This library will handle UTF8\n   properly, but everything else is just spit out as ASCII.\n3. It assumes that ID3v2 tags are always the very first thing in the file (as they\n   should be). The spec is mum on whether that's ''required'', but this library\n   assumes it is.\n4. ID3v1.1 (extended tags with \"TAG+\") are not supported; Wikipedia suggests they\n   aren't really well-supported in media players anyway.\n\nAs such, the code is a bit abstruse, in that you'll see some magic numbers, like\n`offset += 94` where it's ignoring a bunch of header data to get to the good stuff.\nDon't judge me based on this code. It works and it's tested; it's just hard to\nread.\n\nOf course, since this isn't an actual parser, invalid files will also work. This\nmeans, for example, you could only read the first couple hundred bytes of an MP3\nfile and still extract the metadata from it, rather than requiring actual valid\nMP3 data.\n\n## Usage\nThe library operates solely on `ArrayBuffer`s, or `Buffer`s for Node's convenience.\nSo you'll need to preload your audio data before using this library.\n\nThe library defines three methods:\n\n```javascript\n// extract comments from OGG container\nAudioMetaData.ogg(buffer)\n\n// extract ID3v2 tags\nAudioMetaData.id3v2(buffer);\n\n// extract ID3v1 tags\nAudioMetaData.<span class="apidocCodeKeywordSpan">id3v1</span>(buffer);\n```\n\nThe result is an object with the metadata. It attempts to normalize common keys:\n\n* ''title'': (`TIT1` and `TIT2` in id3v2)\n* ''artist'' (`TSE1` in id3v2)\n* ''composer'' (`TCOM` in id3v2)\n* ''album'' (`TALB` in id3v2)\n* ''track'' (`TRCK` in id3v2, commonly `TRACKNUMBER` in vorbis comments)\n* ''year'' (`TDRC` (date recorded) is used in id3v2)\n* ''encoder'' (`TSSE` in id3v2)\n* ''genre'' (`TCON` in id3v2)\n\nEverything else will be keyed by its original name. For id3v2,\nanything that is not a text identifier (i.e. a frame that starts with a\n\"T\") is ignored. This includes comments (`COMM`).\n\n### Node\nInstall it using NPM: `npm install audio-metadata` or `npm install -g audio-metadata`\nif you want to use it from the shell.\n\n```javascript\nvar audioMetaData = require('audio-metadata'),\n\tfs = require('fs');\n\nvar oggData = fs.readFileSync('/path/to/my.ogg');\nvar metadata = audioMetaData.ogg(oggData);\n/*\n{\n  \"title\": \"Contra Base Snippet\",\n  \"artist\": \"Konami\",\n  \"album\": \"Bill and Lance's Excellent Adventure\",\n  \"year\": \"1988\",\n  \"tracknumber\": \"1\",\n  \"track\": \"1\",\n  \"encoder\": \"Lavf53.21.1\"\n}\n*/\n```\n\n#### From the Shell\n```\nExtract metadata from audio files\n\nUSAGE\naudio-metadata --type &lt;type&gt; [options] file1 [file2...]\n\nOPTIONS\n--help,-h\n  This help\n--type,-t &lt;type&gt;\n  One of \"id3v1\", \"id3v2\" or \"ogg\"\n--chunk-size,-c &lt;size&gt;\n  Read the file in chunks of &lt;size&gt;; default is 512\n--quit-after,-q &lt;length&gt;\n  Stop searching for metadata if nothing is found after\n  &lt;length&gt; bytes; default is 512\n--no-colors,-z\n  Don't colorize the output\n\nEXAMPLE\nSearch for metadata in the first 300 bytes in 100 byte increments\n audio-metadata -t id3v2 -c 100 -q 300 keepitoffmy.wav\n ```\n\n### Browser\nThis library has been tested on current versions of Firefox and Chrome. IE\nmight work, since it apparently supports `ArrayBuffer`. Safari/Opera are\nprobably okayish since they're webkit. Your mileage may vary.\n\nLoading `audio-metadata.min.js` will define the `AudioMetadata` global variable.\n\n```html\n&lt;script type=\"text/javascript\" src=\"audio-metadata.min.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\n\tvar req = new XMLHttpRequest();\n\treq.open('GET', 'http://example.com/sofine.mp3', true);\n\treq.responseType = 'arraybuffer';\n\n\treq.onload = function() {\n\t\tvar metadata = AudioMetaData.id3v2(req.response);\n\t\t/*\n\t\t\t{\n\t\t\t\t\"TIT2\": \"Foobar\",\n\t\t\t\t\"title\": \"Foobar\",\n\t\t\t\t\"TPE1\": \"The Foobars\",\n\t\t\t\t\"artist\": \"The Foobars\",\n\t\t\t\t\"TALB\": \"FUBAR\",\n\t\t\t\t\"album\": \"FUBAR\",\n\t\t\t\t\"year\": \"2014\",\n\t\t\t\t\"TRCK\": \"9\",\n\t\t\t\t\"track\": \"9\",\n\t\t\t\t\"TSSE\": \"Lavf53.21.1\",\n\t\t\t\t\"encoder\": \"Lavf53.21.1\"\n\t\t\t}\n\t\t*/\n\t};\n\n\treq.send(null);\n&lt;/script&gt;\n```\n\n## Development\n```bash\ngit clone git@github.com:tmont/audio-metadata.js\ncd audio-metadata\nnpm install\nnpm test\n```\n\nThere's a \"test\" (yeah, yeah) for browsers, which you can view\nby running `npm start` and then pointing your browser at\n[http://localhost:24578/tests/browser/](http://localhost:24578/tests/browser/).\n\nTo build the minified browserified file, run `npm run minify`.\n",
"readmeFilename": "README.md",
"repository": {
  "type": "git",
  "url": "git+https://github.com/tmont/audio-metadata.git"
},
"scripts": {
  "build": "./node_modules/.bin/browserify -s AudioMetadata -e index.js --bare &gt; audio-metadata.js",
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.audio-metadata.id3v2" id="apidoc.element.audio-metadata.id3v2">
        function <span class="apidocSignatureSpan">audio-metadata.</span>id3v2
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id3v2 = function (buffer) {
	var view = utils.createView(buffer);
	if (!checkMagicId3(view, 0)) {
		return null;
	}

	var offset = 3;
	//var majorVersion = view.getUint8(offset);
	offset += 2;
	var flags = view.getUint8(offset);
	offset++;
	var size = getUint28(view, offset);
	offset += 4;

	var extendedHeader = (flags &amp; 128) &gt; 0;

	if (extendedHeader) {
		offset += getUint28(view, offset);
	}

	function readFrame(offset) {
		try {
			var id = utils.readAscii(view, offset, 4);
			var size = getUint28(view, offset + 4);
			offset += 10; //+2 more for flags we don't care about

			if (id[0] !== 'T') {
				return {
					id: id,
					size: size + 10
				};
			}

			var encoding = view.getUint8(offset),
				data = '';

			if (encoding &lt;= 3) {
				offset++;
				if (encoding === 3) {
					//UTF8 - null terminated
					data = utils.readUtf8(view, offset, size - 1);
				} else {
					//ISO-8859-1, UTF-16, UTF-16BE
					//UTF-16 and UTF-16BE are $FF $00 terminated
					//ISO is null terminated

					//screw these encodings, read it as ascii
					data = utils.readAscii(view, offset, size - 1);
				}
			} else {
				//no encoding info, read it as ascii
				data = utils.readAscii(view, offset, size);
			}

			//id3v2.4 is supposed to have encoding terminations, but sometimes
			//they don't? meh.
			data = utils.trimNull(data);

			return {
				id: id,
				size: size + 10,
				content: data
			};
		} catch (e) {
			return null;
		}
	}

	var idMap = {
		TALB: 'album',
		TCOM: 'composer',
		TIT1: 'title',
		TIT2: 'title',
		TPE1: 'artist',
		TRCK: 'track',
		TSSE: 'encoder',
		TDRC: 'year',
		TCON: 'genre'
	};

	var endOfTags = offset + size,
		frames = {};
	while (offset &lt; endOfTags) {
		var frame = readFrame(offset);
		if (!frame) {
			break;
		}

		offset += frame.size;
		if (!frame.content) {
			continue;
		}
		var id = idMap[frame.id] || frame.id;
		if (id === 'TXXX') {
			var nullByte = frame.content.indexOf('\u0000');
			id = frame.content.substring(0, nullByte);
			frames[id] = frame.content.substring(nullByte + 1);
		} else {
			frames[id] = frames[frame.id] = frame.content;
		}
	}

	return frames;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "tmont",
    "email": "tommy.mont@gmail.com"
  }
],
"name": "audio-metadata",
"optionalDependencies": {},
"readme": "# audio-metadata\n\n[![Build Status](https://travis-ci.org/tmont/audio-metadata.png)](https://travis-ci
.org/tmont/audio-metadata)\n[![NPM version](https://badge.fury.io/js/audio-metadata.png)](http://badge.fury.io/js/audio-metadata)\n\nThis is a tinyish (2.1K gzipped) library to extract metadata from audio files.\nSpecifically, it can extract [ID3v1](http://en.wikipedia.org/wiki/ID3#ID3v1),\n[ID3v2](http://en.wikipedia.org/wiki/ID3#ID3v2) and\n[Vorbis comments](http://www.xiph.org/vorbis/doc/v-comment.html)\n(i.e. metadata in [OGG containers](http://en.wikipedia.org/wiki/Ogg)).\n\nLicensed under the [WTFPL](http://www.wtfpl.net/).\n\n## What is this good for?\nThe purpose of this library is to be very fast and small. It's suitable\nfor server-side or client-side. Really any platform that supports\n`ArrayBuffer` and its ilk (`Uint8Array`, etc.).\n\nI wrote it because the other libraries were large and very robust; I just\nneeded something that could extract the metadata out without requiring\n30KB of JavaScript. `audio-metadata.min.js` comes in at 6.1K/2.1K\nminified/gzipped.\n\nTo accomplish the small size and speed, it sacrifices several things.\n\n1. It's very naive. For example, the OGG format stipulates that the comment\n   header must come second, after the identification header. This library\n   assumes that's always true and ignores the header type byte.\n2. Text encoding is for losers. ID3v2 in particular has a lot of flexibility in\n   terms of the encoding of text for ID3 frames. This library will handle UTF8\n   properly, but everything else is just spit out as ASCII.\n3. It assumes that ID3v2 tags are always the very first thing in the file (as they\n   should be). The spec is mum on whether that's ''required'', but this library\n   assumes it is.\n4. ID3v1.1 (extended tags with \"TAG+\") are not supported; Wikipedia suggests they\n   aren't really well-supported in media players anyway.\n\nAs such, the code is a bit abstruse, in that you'll see some magic numbers, like\n`offset += 94` where it's ignoring a bunch of header data to get to the good stuff.\nDon't judge me based on this code. It works and it's tested; it's just hard to\nread.\n\nOf course, since this isn't an actual parser, invalid files will also work. This\nmeans, for example, you could only read the first couple hundred bytes of an MP3\nfile and still extract the metadata from it, rather than requiring actual valid\nMP3 data.\n\n## Usage\nThe library operates solely on `ArrayBuffer`s, or `Buffer`s for Node's convenience.\nSo you'll need to preload your audio data before using this library.\n\nThe library defines three methods:\n\n```javascript\n// extract comments from OGG container\nAudioMetaData.ogg(buffer)\n\n// extract ID3v2 tags\nAudioMetaData.<span class="apidocCodeKeywordSpan">id3v2</span>(buffer);\n\n// extract ID3v1 tags\nAudioMetaData.id3v1(buffer);\n```\n\nThe result is an object with the metadata. It attempts to normalize common keys:\n\n* ''title'': (`TIT1` and `TIT2` in id3v2)\n* ''artist'' (`TSE1` in id3v2)\n* ''composer'' (`TCOM` in id3v2)\n* ''album'' (`TALB` in id3v2)\n* ''track'' (`TRCK` in id3v2, commonly `TRACKNUMBER` in vorbis comments)\n* ''year'' (`TDRC` (date recorded) is used in id3v2)\n* ''encoder'' (`TSSE` in id3v2)\n* ''genre'' (`TCON` in id3v2)\n\nEverything else will be keyed by its original name. For id3v2,\nanything that is not a text identifier (i.e. a frame that starts with a\n\"T\") is ignored. This includes comments (`COMM`).\n\n### Node\nInstall it using NPM: `npm install audio-metadata` or `npm install -g audio-metadata`\nif you want to use it from the shell.\n\n```javascript\nvar audioMetaData = require('audio-metadata'),\n\tfs = require('fs');\n\nvar oggData = fs.readFileSync('/path/to/my.ogg');\nvar metadata = audioMetaData.ogg(oggData);\n/*\n{\n  \"title\": \"Contra Base Snippet\",\n  \"artist\": \"Konami\",\n  \"album\": \"Bill and Lance's Excellent Adventure\",\n  \"year\": \"1988\",\n  \"tracknumber\": \"1\",\n  \"track\": \"1\",\n  \"encoder\": \"Lavf53.21.1\"\n}\n*/\n```\n\n#### From the Shell\n```\nExtract metadata from audio files\n\nUSAGE\naudio-metadata --type &lt;type&gt; [options] file1 [file2...]\n\nOPTIONS\n--help,-h\n  This help\n--type,-t &lt;type&gt;\n  One of \"id3v1\", \"id3v2\" or \"ogg\"\n--chunk-size,-c &lt;size&gt;\n  Read the file in chunks of &lt;size&gt;; default is 512\n--quit-after,-q &lt;length&gt;\n  Stop searching for metadata if nothing is found after\n  &lt;length&gt; bytes; default is 512\n--no-colors,-z\n  Don't colorize the output\n\nEXAMPLE\nSearch for metadata in the first 300 bytes in 100 byte increments\n audio-metadata -t id3v2 -c 100 -q 300 keepitoffmy.wav\n ```\n\n### Browser\nThis library has been tested on current versions of Firefox and Chrome. IE\nmight work, since it apparently supports `ArrayBuffer`. Safari/Opera are\nprobably okayish since they're webkit. Your mileage may vary.\n\nLoading `audio-metadata.min.js` will define the `AudioMetadata` global variable.\n\n```html\n&lt;script type=\"text/javascript\" src=\"audio-metadata.min.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\n\tvar req = new XMLHttpRequest();\n\treq.open('GET', 'http://example.com/sofine.mp3', true);\n\treq.responseType = 'arraybuffer';\n\n\treq.onload = function() {\n\t\tvar metadata = AudioMetaData.id3v2(req.response);\n\t\t/*\n\t\t\t{\n\t\t\t\t\"TIT2\": \"Foobar\",\n\t\t\t\t\"title\": \"Foobar\",\n\t\t\t\t\"TPE1\": \"The Foobars\",\n\t\t\t\t\"artist\": \"The Foobars\",\n\t\t\t\t\"TALB\": \"FUBAR\",\n\t\t\t\t\"album\": \"FUBAR\",\n\t\t\t\t\"year\": \"2014\",\n\t\t\t\t\"TRCK\": \"9\",\n\t\t\t\t\"track\": \"9\",\n\t\t\t\t\"TSSE\": \"Lavf53.21.1\",\n\t\t\t\t\"encoder\": \"Lavf53.21.1\"\n\t\t\t}\n\t\t*/\n\t};\n\n\treq.send(null);\n&lt;/script&gt;\n```\n\n## Development\n```bash\ngit clone git@github.com:tmont/audio-metadata.js\ncd audio-metadata\nnpm install\nnpm test\n```\n\nThere's a \"test\" (yeah, yeah) for browsers, which you can view\nby running `npm start` and then pointing your browser at\n[http://localhost:24578/tests/browser/](http://localhost:24578/tests/browser/).\n\nTo build the minified browserified file, run `npm run minify`.\n",
"readmeFilename": "README.md",
"repository": {
  "type": "git",
  "url": "git+https://github.com/tmont/audio-metadata.git"
},
"scripts": {
  "build": "./node_modules/.bin/browserify -s AudioMetadata -e index.js --bare &gt; audio-metadata.js",
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.audio-metadata.ogg" id="apidoc.element.audio-metadata.ogg">
        function <span class="apidocSignatureSpan">audio-metadata.</span>ogg
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ogg = function (buffer) {
	var view = utils.createView(buffer);

	function parsePage(offset, withPacket) {
		if (view.byteLength &lt; offset + 27) {
			return null;
		}

		var numPageSegments = view.getUint8(offset + 26),
			segmentTable = utils.readBytes(view, offset + 27, numPageSegments),
			headerSize = 27 + numPageSegments;

		if (!segmentTable.length) {
			return null;
		}

		var
			pageSize = headerSize + segmentTable.reduce(function(cur, next) {
				return cur + next;
			}),
			length = headerSize + 1 + 'vorbis'.length,
			packetView = null;

		if (withPacket) {
			packetView = utils.createView(new ArrayBuffer(pageSize - length));
			utils.readBytes(view, offset + length, pageSize - length, packetView);
		}

		return {
			pageSize: pageSize,
			packet: packetView
		};
	}

	function parseComments(packet) {
		try {
			var vendorLength = packet.getUint32(0, true),
				commentListLength = packet.getUint32(4 + vendorLength, true),
				comments = {},
				offset = 8 + vendorLength,
				map = {
					tracknumber: 'track'
				};

			for (var i = 0; i &lt; commentListLength; i++) {
				var commentLength = packet.getUint32(offset, true),
					comment = utils.readUtf8(packet, offset + 4, commentLength),
					equals = comment.indexOf('='),
					key = comment.substring(0, equals).toLowerCase();

				comments[map[key] || key] = comments[key] = utils.trimNull(comment.substring(equals + 1));
				offset += 4 + commentLength;
			}

			return comments;
		} catch (e) {
			//all exceptions are just malformed/truncated data, so we just ignore them
			return null;
		}
	}

	var id = parsePage(0);
	if (!id) {
		return null;
	}

	var commentHeader = parsePage(id.pageSize, true);
	if (!commentHeader) {
		return null;
	}

	return parseComments(commentHeader.packet);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "tmont",
    "email": "tommy.mont@gmail.com"
  }
],
"name": "audio-metadata",
"optionalDependencies": {},
"readme": "# audio-metadata\n\n[![Build Status](https://travis-ci.org/tmont/audio-metadata.png)](https://travis-ci
.org/tmont/audio-metadata)\n[![NPM version](https://badge.fury.io/js/audio-metadata.png)](http://badge.fury.io/js/audio-metadata)\n\nThis is a tinyish (2.1K gzipped) library to extract metadata from audio files.\nSpecifically, it can extract [ID3v1](http://en.wikipedia.org/wiki/ID3#ID3v1),\n[ID3v2](http://en.wikipedia.org/wiki/ID3#ID3v2) and\n[Vorbis comments](http://www.xiph.org/vorbis/doc/v-comment.html)\n(i.e. metadata in [OGG containers](http://en.wikipedia.org/wiki/Ogg)).\n\nLicensed under the [WTFPL](http://www.wtfpl.net/).\n\n## What is this good for?\nThe purpose of this library is to be very fast and small. It's suitable\nfor server-side or client-side. Really any platform that supports\n`ArrayBuffer` and its ilk (`Uint8Array`, etc.).\n\nI wrote it because the other libraries were large and very robust; I just\nneeded something that could extract the metadata out without requiring\n30KB of JavaScript. `audio-metadata.min.js` comes in at 6.1K/2.1K\nminified/gzipped.\n\nTo accomplish the small size and speed, it sacrifices several things.\n\n1. It's very naive. For example, the OGG format stipulates that the comment\n   header must come second, after the identification header. This library\n   assumes that's always true and ignores the header type byte.\n2. Text encoding is for losers. ID3v2 in particular has a lot of flexibility in\n   terms of the encoding of text for ID3 frames. This library will handle UTF8\n   properly, but everything else is just spit out as ASCII.\n3. It assumes that ID3v2 tags are always the very first thing in the file (as they\n   should be). The spec is mum on whether that's ''required'', but this library\n   assumes it is.\n4. ID3v1.1 (extended tags with \"TAG+\") are not supported; Wikipedia suggests they\n   aren't really well-supported in media players anyway.\n\nAs such, the code is a bit abstruse, in that you'll see some magic numbers, like\n`offset += 94` where it's ignoring a bunch of header data to get to the good stuff.\nDon't judge me based on this code. It works and it's tested; it's just hard to\nread.\n\nOf course, since this isn't an actual parser, invalid files will also work. This\nmeans, for example, you could only read the first couple hundred bytes of an MP3\nfile and still extract the metadata from it, rather than requiring actual valid\nMP3 data.\n\n## Usage\nThe library operates solely on `ArrayBuffer`s, or `Buffer`s for Node's convenience.\nSo you'll need to preload your audio data before using this library.\n\nThe library defines three methods:\n\n```javascript\n// extract comments from OGG container\nAudioMetaData.<span class="apidocCodeKeywordSpan">ogg</span>(buffer)\n\n// extract ID3v2 tags\nAudioMetaData.id3v2(buffer);\n\n// extract ID3v1 tags\nAudioMetaData.id3v1(buffer);\n```\n\nThe result is an object with the metadata. It attempts to normalize common keys:\n\n* ''title'': (`TIT1` and `TIT2` in id3v2)\n* ''artist'' (`TSE1` in id3v2)\n* ''composer'' (`TCOM` in id3v2)\n* ''album'' (`TALB` in id3v2)\n* ''track'' (`TRCK` in id3v2, commonly `TRACKNUMBER` in vorbis comments)\n* ''year'' (`TDRC` (date recorded) is used in id3v2)\n* ''encoder'' (`TSSE` in id3v2)\n* ''genre'' (`TCON` in id3v2)\n\nEverything else will be keyed by its original name. For id3v2,\nanything that is not a text identifier (i.e. a frame that starts with a\n\"T\") is ignored. This includes comments (`COMM`).\n\n### Node\nInstall it using NPM: `npm install audio-metadata` or `npm install -g audio-metadata`\nif you want to use it from the shell.\n\n```javascript\nvar audioMetaData = require('audio-metadata'),\n\tfs = require('fs');\n\nvar oggData = fs.readFileSync('/path/to/my.ogg');\nvar metadata = audioMetaData.ogg(oggData);\n/*\n{\n  \"title\": \"Contra Base Snippet\",\n  \"artist\": \"Konami\",\n  \"album\": \"Bill and Lance's Excellent Adventure\",\n  \"year\": \"1988\",\n  \"tracknumber\": \"1\",\n  \"track\": \"1\",\n  \"encoder\": \"Lavf53.21.1\"\n}\n*/\n```\n\n#### From the Shell\n```\nExtract metadata from audio files\n\nUSAGE\naudio-metadata --type &lt;type&gt; [options] file1 [file2...]\n\nOPTIONS\n--help,-h\n  This help\n--type,-t &lt;type&gt;\n  One of \"id3v1\", \"id3v2\" or \"ogg\"\n--chunk-size,-c &lt;size&gt;\n  Read the file in chunks of &lt;size&gt;; default is 512\n--quit-after,-q &lt;length&gt;\n  Stop searching for metadata if nothing is found after\n  &lt;length&gt; bytes; default is 512\n--no-colors,-z\n  Don't colorize the output\n\nEXAMPLE\nSearch for metadata in the first 300 bytes in 100 byte increments\n audio-metadata -t id3v2 -c 100 -q 300 keepitoffmy.wav\n ```\n\n### Browser\nThis library has been tested on current versions of Firefox and Chrome. IE\nmight work, since it apparently supports `ArrayBuffer`. Safari/Opera are\nprobably okayish since they're webkit. Your mileage may vary.\n\nLoading `audio-metadata.min.js` will define the `AudioMetadata` global variable.\n\n```html\n&lt;script type=\"text/javascript\" src=\"audio-metadata.min.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\n\tvar req = new XMLHttpRequest();\n\treq.open('GET', 'http://example.com/sofine.mp3', true);\n\treq.responseType = 'arraybuffer';\n\n\treq.onload = function() {\n\t\tvar metadata = AudioMetaData.id3v2(req.response);\n\t\t/*\n\t\t\t{\n\t\t\t\t\"TIT2\": \"Foobar\",\n\t\t\t\t\"title\": \"Foobar\",\n\t\t\t\t\"TPE1\": \"The Foobars\",\n\t\t\t\t\"artist\": \"The Foobars\",\n\t\t\t\t\"TALB\": \"FUBAR\",\n\t\t\t\t\"album\": \"FUBAR\",\n\t\t\t\t\"year\": \"2014\",\n\t\t\t\t\"TRCK\": \"9\",\n\t\t\t\t\"track\": \"9\",\n\t\t\t\t\"TSSE\": \"Lavf53.21.1\",\n\t\t\t\t\"encoder\": \"Lavf53.21.1\"\n\t\t\t}\n\t\t*/\n\t};\n\n\treq.send(null);\n&lt;/script&gt;\n```\n\n## Development\n```bash\ngit clone git@github.com:tmont/audio-metadata.js\ncd audio-metadata\nnpm install\nnpm test\n```\n\nThere's a \"test\" (yeah, yeah) for browsers, which you can view\nby running `npm start` and then pointing your browser at\n[http://localhost:24578/tests/browser/](http://localhost:24578/tests/browser/).\n\nTo build the minified browserified file, run `npm run minify`.\n",
"readmeFilename": "README.md",
"repository": {
  "type": "git",
  "url": "git+https://github.com/tmont/audio-metadata.git"
},
"scripts": {
  "build": "./node_modules/.bin/browserify -s AudioMetadata -e index.js --bare &gt; audio-metadata.js",
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.audio-metadata.index" id="apidoc.module.audio-metadata.index">module audio-metadata.index</a></h1>


    <h2>
        <a href="#apidoc.element.audio-metadata.index.id3v1" id="apidoc.element.audio-metadata.index.id3v1">
        function <span class="apidocSignatureSpan">audio-metadata.index.</span>id3v1
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id3v1 = function (buffer) {
	//read last 128 bytes
	var view = utils.createView(buffer);
	if (!checkMagicId3v1(view)) {
		return null;
	}

	function trim(value) {
		return value.replace(/[\s\u0000]+$/, '');
	}

	try {
		var offset = view.byteLength - 128 + 3,
			readAscii = utils.readAscii;
		var title = readAscii(view, offset, 30),
			artist = readAscii(view, offset + 30, 30),
			album = readAscii(view, offset + 60, 30),
			year = readAscii(view, offset + 90, 4);

		offset += 94;

		var comment = readAscii(view, offset, 28),
			track = null;
		offset += 28;
		if (view.getUint8(offset) === 0) {
			//next byte is the track
			track = view.getUint8(offset + 1);
		} else {
			comment += readAscii(view, offset, 2);
		}

		offset += 2;
		var genre = view.getUint8(offset);
		return {
			title: trim(title),
			artist: trim(artist),
			album: trim(album),
			year: trim(year),
			comment: trim(comment),
			track: track,
			genre: genre
		};
	} catch (e) {
		return null;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "tmont",
    "email": "tommy.mont@gmail.com"
  }
],
"name": "audio-metadata",
"optionalDependencies": {},
"readme": "# audio-metadata\n\n[![Build Status](https://travis-ci.org/tmont/audio-metadata.png)](https://travis-ci
.org/tmont/audio-metadata)\n[![NPM version](https://badge.fury.io/js/audio-metadata.png)](http://badge.fury.io/js/audio-metadata)\n\nThis is a tinyish (2.1K gzipped) library to extract metadata from audio files.\nSpecifically, it can extract [ID3v1](http://en.wikipedia.org/wiki/ID3#ID3v1),\n[ID3v2](http://en.wikipedia.org/wiki/ID3#ID3v2) and\n[Vorbis comments](http://www.xiph.org/vorbis/doc/v-comment.html)\n(i.e. metadata in [OGG containers](http://en.wikipedia.org/wiki/Ogg)).\n\nLicensed under the [WTFPL](http://www.wtfpl.net/).\n\n## What is this good for?\nThe purpose of this library is to be very fast and small. It's suitable\nfor server-side or client-side. Really any platform that supports\n`ArrayBuffer` and its ilk (`Uint8Array`, etc.).\n\nI wrote it because the other libraries were large and very robust; I just\nneeded something that could extract the metadata out without requiring\n30KB of JavaScript. `audio-metadata.min.js` comes in at 6.1K/2.1K\nminified/gzipped.\n\nTo accomplish the small size and speed, it sacrifices several things.\n\n1. It's very naive. For example, the OGG format stipulates that the comment\n   header must come second, after the identification header. This library\n   assumes that's always true and ignores the header type byte.\n2. Text encoding is for losers. ID3v2 in particular has a lot of flexibility in\n   terms of the encoding of text for ID3 frames. This library will handle UTF8\n   properly, but everything else is just spit out as ASCII.\n3. It assumes that ID3v2 tags are always the very first thing in the file (as they\n   should be). The spec is mum on whether that's ''required'', but this library\n   assumes it is.\n4. ID3v1.1 (extended tags with \"TAG+\") are not supported; Wikipedia suggests they\n   aren't really well-supported in media players anyway.\n\nAs such, the code is a bit abstruse, in that you'll see some magic numbers, like\n`offset += 94` where it's ignoring a bunch of header data to get to the good stuff.\nDon't judge me based on this code. It works and it's tested; it's just hard to\nread.\n\nOf course, since this isn't an actual parser, invalid files will also work. This\nmeans, for example, you could only read the first couple hundred bytes of an MP3\nfile and still extract the metadata from it, rather than requiring actual valid\nMP3 data.\n\n## Usage\nThe library operates solely on `ArrayBuffer`s, or `Buffer`s for Node's convenience.\nSo you'll need to preload your audio data before using this library.\n\nThe library defines three methods:\n\n```javascript\n// extract comments from OGG container\nAudioMetaData.ogg(buffer)\n\n// extract ID3v2 tags\nAudioMetaData.id3v2(buffer);\n\n// extract ID3v1 tags\nAudioMetaData.<span class="apidocCodeKeywordSpan">id3v1</span>(buffer);\n```\n\nThe result is an object with the metadata. It attempts to normalize common keys:\n\n* ''title'': (`TIT1` and `TIT2` in id3v2)\n* ''artist'' (`TSE1` in id3v2)\n* ''composer'' (`TCOM` in id3v2)\n* ''album'' (`TALB` in id3v2)\n* ''track'' (`TRCK` in id3v2, commonly `TRACKNUMBER` in vorbis comments)\n* ''year'' (`TDRC` (date recorded) is used in id3v2)\n* ''encoder'' (`TSSE` in id3v2)\n* ''genre'' (`TCON` in id3v2)\n\nEverything else will be keyed by its original name. For id3v2,\nanything that is not a text identifier (i.e. a frame that starts with a\n\"T\") is ignored. This includes comments (`COMM`).\n\n### Node\nInstall it using NPM: `npm install audio-metadata` or `npm install -g audio-metadata`\nif you want to use it from the shell.\n\n```javascript\nvar audioMetaData = require('audio-metadata'),\n\tfs = require('fs');\n\nvar oggData = fs.readFileSync('/path/to/my.ogg');\nvar metadata = audioMetaData.ogg(oggData);\n/*\n{\n  \"title\": \"Contra Base Snippet\",\n  \"artist\": \"Konami\",\n  \"album\": \"Bill and Lance's Excellent Adventure\",\n  \"year\": \"1988\",\n  \"tracknumber\": \"1\",\n  \"track\": \"1\",\n  \"encoder\": \"Lavf53.21.1\"\n}\n*/\n```\n\n#### From the Shell\n```\nExtract metadata from audio files\n\nUSAGE\naudio-metadata --type &lt;type&gt; [options] file1 [file2...]\n\nOPTIONS\n--help,-h\n  This help\n--type,-t &lt;type&gt;\n  One of \"id3v1\", \"id3v2\" or \"ogg\"\n--chunk-size,-c &lt;size&gt;\n  Read the file in chunks of &lt;size&gt;; default is 512\n--quit-after,-q &lt;length&gt;\n  Stop searching for metadata if nothing is found after\n  &lt;length&gt; bytes; default is 512\n--no-colors,-z\n  Don't colorize the output\n\nEXAMPLE\nSearch for metadata in the first 300 bytes in 100 byte increments\n audio-metadata -t id3v2 -c 100 -q 300 keepitoffmy.wav\n ```\n\n### Browser\nThis library has been tested on current versions of Firefox and Chrome. IE\nmight work, since it apparently supports `ArrayBuffer`. Safari/Opera are\nprobably okayish since they're webkit. Your mileage may vary.\n\nLoading `audio-metadata.min.js` will define the `AudioMetadata` global variable.\n\n```html\n&lt;script type=\"text/javascript\" src=\"audio-metadata.min.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\n\tvar req = new XMLHttpRequest();\n\treq.open('GET', 'http://example.com/sofine.mp3', true);\n\treq.responseType = 'arraybuffer';\n\n\treq.onload = function() {\n\t\tvar metadata = AudioMetaData.id3v2(req.response);\n\t\t/*\n\t\t\t{\n\t\t\t\t\"TIT2\": \"Foobar\",\n\t\t\t\t\"title\": \"Foobar\",\n\t\t\t\t\"TPE1\": \"The Foobars\",\n\t\t\t\t\"artist\": \"The Foobars\",\n\t\t\t\t\"TALB\": \"FUBAR\",\n\t\t\t\t\"album\": \"FUBAR\",\n\t\t\t\t\"year\": \"2014\",\n\t\t\t\t\"TRCK\": \"9\",\n\t\t\t\t\"track\": \"9\",\n\t\t\t\t\"TSSE\": \"Lavf53.21.1\",\n\t\t\t\t\"encoder\": \"Lavf53.21.1\"\n\t\t\t}\n\t\t*/\n\t};\n\n\treq.send(null);\n&lt;/script&gt;\n```\n\n## Development\n```bash\ngit clone git@github.com:tmont/audio-metadata.js\ncd audio-metadata\nnpm install\nnpm test\n```\n\nThere's a \"test\" (yeah, yeah) for browsers, which you can view\nby running `npm start` and then pointing your browser at\n[http://localhost:24578/tests/browser/](http://localhost:24578/tests/browser/).\n\nTo build the minified browserified file, run `npm run minify`.\n",
"readmeFilename": "README.md",
"repository": {
  "type": "git",
  "url": "git+https://github.com/tmont/audio-metadata.git"
},
"scripts": {
  "build": "./node_modules/.bin/browserify -s AudioMetadata -e index.js --bare &gt; audio-metadata.js",
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.audio-metadata.index.id3v2" id="apidoc.element.audio-metadata.index.id3v2">
        function <span class="apidocSignatureSpan">audio-metadata.index.</span>id3v2
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id3v2 = function (buffer) {
	var view = utils.createView(buffer);
	if (!checkMagicId3(view, 0)) {
		return null;
	}

	var offset = 3;
	//var majorVersion = view.getUint8(offset);
	offset += 2;
	var flags = view.getUint8(offset);
	offset++;
	var size = getUint28(view, offset);
	offset += 4;

	var extendedHeader = (flags &amp; 128) &gt; 0;

	if (extendedHeader) {
		offset += getUint28(view, offset);
	}

	function readFrame(offset) {
		try {
			var id = utils.readAscii(view, offset, 4);
			var size = getUint28(view, offset + 4);
			offset += 10; //+2 more for flags we don't care about

			if (id[0] !== 'T') {
				return {
					id: id,
					size: size + 10
				};
			}

			var encoding = view.getUint8(offset),
				data = '';

			if (encoding &lt;= 3) {
				offset++;
				if (encoding === 3) {
					//UTF8 - null terminated
					data = utils.readUtf8(view, offset, size - 1);
				} else {
					//ISO-8859-1, UTF-16, UTF-16BE
					//UTF-16 and UTF-16BE are $FF $00 terminated
					//ISO is null terminated

					//screw these encodings, read it as ascii
					data = utils.readAscii(view, offset, size - 1);
				}
			} else {
				//no encoding info, read it as ascii
				data = utils.readAscii(view, offset, size);
			}

			//id3v2.4 is supposed to have encoding terminations, but sometimes
			//they don't? meh.
			data = utils.trimNull(data);

			return {
				id: id,
				size: size + 10,
				content: data
			};
		} catch (e) {
			return null;
		}
	}

	var idMap = {
		TALB: 'album',
		TCOM: 'composer',
		TIT1: 'title',
		TIT2: 'title',
		TPE1: 'artist',
		TRCK: 'track',
		TSSE: 'encoder',
		TDRC: 'year',
		TCON: 'genre'
	};

	var endOfTags = offset + size,
		frames = {};
	while (offset &lt; endOfTags) {
		var frame = readFrame(offset);
		if (!frame) {
			break;
		}

		offset += frame.size;
		if (!frame.content) {
			continue;
		}
		var id = idMap[frame.id] || frame.id;
		if (id === 'TXXX') {
			var nullByte = frame.content.indexOf('\u0000');
			id = frame.content.substring(0, nullByte);
			frames[id] = frame.content.substring(nullByte + 1);
		} else {
			frames[id] = frames[frame.id] = frame.content;
		}
	}

	return frames;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "tmont",
    "email": "tommy.mont@gmail.com"
  }
],
"name": "audio-metadata",
"optionalDependencies": {},
"readme": "# audio-metadata\n\n[![Build Status](https://travis-ci.org/tmont/audio-metadata.png)](https://travis-ci
.org/tmont/audio-metadata)\n[![NPM version](https://badge.fury.io/js/audio-metadata.png)](http://badge.fury.io/js/audio-metadata)\n\nThis is a tinyish (2.1K gzipped) library to extract metadata from audio files.\nSpecifically, it can extract [ID3v1](http://en.wikipedia.org/wiki/ID3#ID3v1),\n[ID3v2](http://en.wikipedia.org/wiki/ID3#ID3v2) and\n[Vorbis comments](http://www.xiph.org/vorbis/doc/v-comment.html)\n(i.e. metadata in [OGG containers](http://en.wikipedia.org/wiki/Ogg)).\n\nLicensed under the [WTFPL](http://www.wtfpl.net/).\n\n## What is this good for?\nThe purpose of this library is to be very fast and small. It's suitable\nfor server-side or client-side. Really any platform that supports\n`ArrayBuffer` and its ilk (`Uint8Array`, etc.).\n\nI wrote it because the other libraries were large and very robust; I just\nneeded something that could extract the metadata out without requiring\n30KB of JavaScript. `audio-metadata.min.js` comes in at 6.1K/2.1K\nminified/gzipped.\n\nTo accomplish the small size and speed, it sacrifices several things.\n\n1. It's very naive. For example, the OGG format stipulates that the comment\n   header must come second, after the identification header. This library\n   assumes that's always true and ignores the header type byte.\n2. Text encoding is for losers. ID3v2 in particular has a lot of flexibility in\n   terms of the encoding of text for ID3 frames. This library will handle UTF8\n   properly, but everything else is just spit out as ASCII.\n3. It assumes that ID3v2 tags are always the very first thing in the file (as they\n   should be). The spec is mum on whether that's ''required'', but this library\n   assumes it is.\n4. ID3v1.1 (extended tags with \"TAG+\") are not supported; Wikipedia suggests they\n   aren't really well-supported in media players anyway.\n\nAs such, the code is a bit abstruse, in that you'll see some magic numbers, like\n`offset += 94` where it's ignoring a bunch of header data to get to the good stuff.\nDon't judge me based on this code. It works and it's tested; it's just hard to\nread.\n\nOf course, since this isn't an actual parser, invalid files will also work. This\nmeans, for example, you could only read the first couple hundred bytes of an MP3\nfile and still extract the metadata from it, rather than requiring actual valid\nMP3 data.\n\n## Usage\nThe library operates solely on `ArrayBuffer`s, or `Buffer`s for Node's convenience.\nSo you'll need to preload your audio data before using this library.\n\nThe library defines three methods:\n\n```javascript\n// extract comments from OGG container\nAudioMetaData.ogg(buffer)\n\n// extract ID3v2 tags\nAudioMetaData.<span class="apidocCodeKeywordSpan">id3v2</span>(buffer);\n\n// extract ID3v1 tags\nAudioMetaData.id3v1(buffer);\n```\n\nThe result is an object with the metadata. It attempts to normalize common keys:\n\n* ''title'': (`TIT1` and `TIT2` in id3v2)\n* ''artist'' (`TSE1` in id3v2)\n* ''composer'' (`TCOM` in id3v2)\n* ''album'' (`TALB` in id3v2)\n* ''track'' (`TRCK` in id3v2, commonly `TRACKNUMBER` in vorbis comments)\n* ''year'' (`TDRC` (date recorded) is used in id3v2)\n* ''encoder'' (`TSSE` in id3v2)\n* ''genre'' (`TCON` in id3v2)\n\nEverything else will be keyed by its original name. For id3v2,\nanything that is not a text identifier (i.e. a frame that starts with a\n\"T\") is ignored. This includes comments (`COMM`).\n\n### Node\nInstall it using NPM: `npm install audio-metadata` or `npm install -g audio-metadata`\nif you want to use it from the shell.\n\n```javascript\nvar audioMetaData = require('audio-metadata'),\n\tfs = require('fs');\n\nvar oggData = fs.readFileSync('/path/to/my.ogg');\nvar metadata = audioMetaData.ogg(oggData);\n/*\n{\n  \"title\": \"Contra Base Snippet\",\n  \"artist\": \"Konami\",\n  \"album\": \"Bill and Lance's Excellent Adventure\",\n  \"year\": \"1988\",\n  \"tracknumber\": \"1\",\n  \"track\": \"1\",\n  \"encoder\": \"Lavf53.21.1\"\n}\n*/\n```\n\n#### From the Shell\n```\nExtract metadata from audio files\n\nUSAGE\naudio-metadata --type &lt;type&gt; [options] file1 [file2...]\n\nOPTIONS\n--help,-h\n  This help\n--type,-t &lt;type&gt;\n  One of \"id3v1\", \"id3v2\" or \"ogg\"\n--chunk-size,-c &lt;size&gt;\n  Read the file in chunks of &lt;size&gt;; default is 512\n--quit-after,-q &lt;length&gt;\n  Stop searching for metadata if nothing is found after\n  &lt;length&gt; bytes; default is 512\n--no-colors,-z\n  Don't colorize the output\n\nEXAMPLE\nSearch for metadata in the first 300 bytes in 100 byte increments\n audio-metadata -t id3v2 -c 100 -q 300 keepitoffmy.wav\n ```\n\n### Browser\nThis library has been tested on current versions of Firefox and Chrome. IE\nmight work, since it apparently supports `ArrayBuffer`. Safari/Opera are\nprobably okayish since they're webkit. Your mileage may vary.\n\nLoading `audio-metadata.min.js` will define the `AudioMetadata` global variable.\n\n```html\n&lt;script type=\"text/javascript\" src=\"audio-metadata.min.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\n\tvar req = new XMLHttpRequest();\n\treq.open('GET', 'http://example.com/sofine.mp3', true);\n\treq.responseType = 'arraybuffer';\n\n\treq.onload = function() {\n\t\tvar metadata = AudioMetaData.id3v2(req.response);\n\t\t/*\n\t\t\t{\n\t\t\t\t\"TIT2\": \"Foobar\",\n\t\t\t\t\"title\": \"Foobar\",\n\t\t\t\t\"TPE1\": \"The Foobars\",\n\t\t\t\t\"artist\": \"The Foobars\",\n\t\t\t\t\"TALB\": \"FUBAR\",\n\t\t\t\t\"album\": \"FUBAR\",\n\t\t\t\t\"year\": \"2014\",\n\t\t\t\t\"TRCK\": \"9\",\n\t\t\t\t\"track\": \"9\",\n\t\t\t\t\"TSSE\": \"Lavf53.21.1\",\n\t\t\t\t\"encoder\": \"Lavf53.21.1\"\n\t\t\t}\n\t\t*/\n\t};\n\n\treq.send(null);\n&lt;/script&gt;\n```\n\n## Development\n```bash\ngit clone git@github.com:tmont/audio-metadata.js\ncd audio-metadata\nnpm install\nnpm test\n```\n\nThere's a \"test\" (yeah, yeah) for browsers, which you can view\nby running `npm start` and then pointing your browser at\n[http://localhost:24578/tests/browser/](http://localhost:24578/tests/browser/).\n\nTo build the minified browserified file, run `npm run minify`.\n",
"readmeFilename": "README.md",
"repository": {
  "type": "git",
  "url": "git+https://github.com/tmont/audio-metadata.git"
},
"scripts": {
  "build": "./node_modules/.bin/browserify -s AudioMetadata -e index.js --bare &gt; audio-metadata.js",
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.audio-metadata.index.ogg" id="apidoc.element.audio-metadata.index.ogg">
        function <span class="apidocSignatureSpan">audio-metadata.index.</span>ogg
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ogg = function (buffer) {
	var view = utils.createView(buffer);

	function parsePage(offset, withPacket) {
		if (view.byteLength &lt; offset + 27) {
			return null;
		}

		var numPageSegments = view.getUint8(offset + 26),
			segmentTable = utils.readBytes(view, offset + 27, numPageSegments),
			headerSize = 27 + numPageSegments;

		if (!segmentTable.length) {
			return null;
		}

		var
			pageSize = headerSize + segmentTable.reduce(function(cur, next) {
				return cur + next;
			}),
			length = headerSize + 1 + 'vorbis'.length,
			packetView = null;

		if (withPacket) {
			packetView = utils.createView(new ArrayBuffer(pageSize - length));
			utils.readBytes(view, offset + length, pageSize - length, packetView);
		}

		return {
			pageSize: pageSize,
			packet: packetView
		};
	}

	function parseComments(packet) {
		try {
			var vendorLength = packet.getUint32(0, true),
				commentListLength = packet.getUint32(4 + vendorLength, true),
				comments = {},
				offset = 8 + vendorLength,
				map = {
					tracknumber: 'track'
				};

			for (var i = 0; i &lt; commentListLength; i++) {
				var commentLength = packet.getUint32(offset, true),
					comment = utils.readUtf8(packet, offset + 4, commentLength),
					equals = comment.indexOf('='),
					key = comment.substring(0, equals).toLowerCase();

				comments[map[key] || key] = comments[key] = utils.trimNull(comment.substring(equals + 1));
				offset += 4 + commentLength;
			}

			return comments;
		} catch (e) {
			//all exceptions are just malformed/truncated data, so we just ignore them
			return null;
		}
	}

	var id = parsePage(0);
	if (!id) {
		return null;
	}

	var commentHeader = parsePage(id.pageSize, true);
	if (!commentHeader) {
		return null;
	}

	return parseComments(commentHeader.packet);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "tmont",
    "email": "tommy.mont@gmail.com"
  }
],
"name": "audio-metadata",
"optionalDependencies": {},
"readme": "# audio-metadata\n\n[![Build Status](https://travis-ci.org/tmont/audio-metadata.png)](https://travis-ci
.org/tmont/audio-metadata)\n[![NPM version](https://badge.fury.io/js/audio-metadata.png)](http://badge.fury.io/js/audio-metadata)\n\nThis is a tinyish (2.1K gzipped) library to extract metadata from audio files.\nSpecifically, it can extract [ID3v1](http://en.wikipedia.org/wiki/ID3#ID3v1),\n[ID3v2](http://en.wikipedia.org/wiki/ID3#ID3v2) and\n[Vorbis comments](http://www.xiph.org/vorbis/doc/v-comment.html)\n(i.e. metadata in [OGG containers](http://en.wikipedia.org/wiki/Ogg)).\n\nLicensed under the [WTFPL](http://www.wtfpl.net/).\n\n## What is this good for?\nThe purpose of this library is to be very fast and small. It's suitable\nfor server-side or client-side. Really any platform that supports\n`ArrayBuffer` and its ilk (`Uint8Array`, etc.).\n\nI wrote it because the other libraries were large and very robust; I just\nneeded something that could extract the metadata out without requiring\n30KB of JavaScript. `audio-metadata.min.js` comes in at 6.1K/2.1K\nminified/gzipped.\n\nTo accomplish the small size and speed, it sacrifices several things.\n\n1. It's very naive. For example, the OGG format stipulates that the comment\n   header must come second, after the identification header. This library\n   assumes that's always true and ignores the header type byte.\n2. Text encoding is for losers. ID3v2 in particular has a lot of flexibility in\n   terms of the encoding of text for ID3 frames. This library will handle UTF8\n   properly, but everything else is just spit out as ASCII.\n3. It assumes that ID3v2 tags are always the very first thing in the file (as they\n   should be). The spec is mum on whether that's ''required'', but this library\n   assumes it is.\n4. ID3v1.1 (extended tags with \"TAG+\") are not supported; Wikipedia suggests they\n   aren't really well-supported in media players anyway.\n\nAs such, the code is a bit abstruse, in that you'll see some magic numbers, like\n`offset += 94` where it's ignoring a bunch of header data to get to the good stuff.\nDon't judge me based on this code. It works and it's tested; it's just hard to\nread.\n\nOf course, since this isn't an actual parser, invalid files will also work. This\nmeans, for example, you could only read the first couple hundred bytes of an MP3\nfile and still extract the metadata from it, rather than requiring actual valid\nMP3 data.\n\n## Usage\nThe library operates solely on `ArrayBuffer`s, or `Buffer`s for Node's convenience.\nSo you'll need to preload your audio data before using this library.\n\nThe library defines three methods:\n\n```javascript\n// extract comments from OGG container\nAudioMetaData.<span class="apidocCodeKeywordSpan">ogg</span>(buffer)\n\n// extract ID3v2 tags\nAudioMetaData.id3v2(buffer);\n\n// extract ID3v1 tags\nAudioMetaData.id3v1(buffer);\n```\n\nThe result is an object with the metadata. It attempts to normalize common keys:\n\n* ''title'': (`TIT1` and `TIT2` in id3v2)\n* ''artist'' (`TSE1` in id3v2)\n* ''composer'' (`TCOM` in id3v2)\n* ''album'' (`TALB` in id3v2)\n* ''track'' (`TRCK` in id3v2, commonly `TRACKNUMBER` in vorbis comments)\n* ''year'' (`TDRC` (date recorded) is used in id3v2)\n* ''encoder'' (`TSSE` in id3v2)\n* ''genre'' (`TCON` in id3v2)\n\nEverything else will be keyed by its original name. For id3v2,\nanything that is not a text identifier (i.e. a frame that starts with a\n\"T\") is ignored. This includes comments (`COMM`).\n\n### Node\nInstall it using NPM: `npm install audio-metadata` or `npm install -g audio-metadata`\nif you want to use it from the shell.\n\n```javascript\nvar audioMetaData = require('audio-metadata'),\n\tfs = require('fs');\n\nvar oggData = fs.readFileSync('/path/to/my.ogg');\nvar metadata = audioMetaData.ogg(oggData);\n/*\n{\n  \"title\": \"Contra Base Snippet\",\n  \"artist\": \"Konami\",\n  \"album\": \"Bill and Lance's Excellent Adventure\",\n  \"year\": \"1988\",\n  \"tracknumber\": \"1\",\n  \"track\": \"1\",\n  \"encoder\": \"Lavf53.21.1\"\n}\n*/\n```\n\n#### From the Shell\n```\nExtract metadata from audio files\n\nUSAGE\naudio-metadata --type &lt;type&gt; [options] file1 [file2...]\n\nOPTIONS\n--help,-h\n  This help\n--type,-t &lt;type&gt;\n  One of \"id3v1\", \"id3v2\" or \"ogg\"\n--chunk-size,-c &lt;size&gt;\n  Read the file in chunks of &lt;size&gt;; default is 512\n--quit-after,-q &lt;length&gt;\n  Stop searching for metadata if nothing is found after\n  &lt;length&gt; bytes; default is 512\n--no-colors,-z\n  Don't colorize the output\n\nEXAMPLE\nSearch for metadata in the first 300 bytes in 100 byte increments\n audio-metadata -t id3v2 -c 100 -q 300 keepitoffmy.wav\n ```\n\n### Browser\nThis library has been tested on current versions of Firefox and Chrome. IE\nmight work, since it apparently supports `ArrayBuffer`. Safari/Opera are\nprobably okayish since they're webkit. Your mileage may vary.\n\nLoading `audio-metadata.min.js` will define the `AudioMetadata` global variable.\n\n```html\n&lt;script type=\"text/javascript\" src=\"audio-metadata.min.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\n\tvar req = new XMLHttpRequest();\n\treq.open('GET', 'http://example.com/sofine.mp3', true);\n\treq.responseType = 'arraybuffer';\n\n\treq.onload = function() {\n\t\tvar metadata = AudioMetaData.id3v2(req.response);\n\t\t/*\n\t\t\t{\n\t\t\t\t\"TIT2\": \"Foobar\",\n\t\t\t\t\"title\": \"Foobar\",\n\t\t\t\t\"TPE1\": \"The Foobars\",\n\t\t\t\t\"artist\": \"The Foobars\",\n\t\t\t\t\"TALB\": \"FUBAR\",\n\t\t\t\t\"album\": \"FUBAR\",\n\t\t\t\t\"year\": \"2014\",\n\t\t\t\t\"TRCK\": \"9\",\n\t\t\t\t\"track\": \"9\",\n\t\t\t\t\"TSSE\": \"Lavf53.21.1\",\n\t\t\t\t\"encoder\": \"Lavf53.21.1\"\n\t\t\t}\n\t\t*/\n\t};\n\n\treq.send(null);\n&lt;/script&gt;\n```\n\n## Development\n```bash\ngit clone git@github.com:tmont/audio-metadata.js\ncd audio-metadata\nnpm install\nnpm test\n```\n\nThere's a \"test\" (yeah, yeah) for browsers, which you can view\nby running `npm start` and then pointing your browser at\n[http://localhost:24578/tests/browser/](http://localhost:24578/tests/browser/).\n\nTo build the minified browserified file, run `npm run minify`.\n",
"readmeFilename": "README.md",
"repository": {
  "type": "git",
  "url": "git+https://github.com/tmont/audio-metadata.git"
},
"scripts": {
  "build": "./node_modules/.bin/browserify -s AudioMetadata -e index.js --bare &gt; audio-metadata.js",
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.audio-metadata.utils" id="apidoc.module.audio-metadata.utils">module audio-metadata.utils</a></h1>


    <h2>
        <a href="#apidoc.element.audio-metadata.utils.createView" id="apidoc.element.audio-metadata.utils.createView">
        function <span class="apidocSignatureSpan">audio-metadata.utils.</span>createView
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createView = function (buffer) {
		if (typeof(Buffer) !== 'undefined' &amp;&amp; buffer instanceof Buffer) {
			//convert nodejs buffers to ArrayBuffer
			buffer = toArrayBuffer(buffer);
		}

		if (!(buffer instanceof ArrayBuffer)) {
			throw new Error('Expected instance of Buffer or ArrayBuffer');
		}

		return new DataView(buffer);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var id3Magic = utils.readBytes(view, view.byteLength - 128, 3);
	//"TAG"
	return id3Magic[0] === 84 &amp;&amp; id3Magic[1] === 65 &amp;&amp; id3Magic[2] === 71;
}

module.exports = function(buffer) {
	//read last 128 bytes
	var view = utils.<span class="apidocCodeKeywordSpan">createView</span>(buffer);
	if (!checkMagicId3v1(view)) {
		return null;
	}

	function trim(value) {
		return value.replace(/[\s\u0000]+$/, '');
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.audio-metadata.utils.readAscii" id="apidoc.element.audio-metadata.utils.readAscii">
        function <span class="apidocSignatureSpan">audio-metadata.utils.</span>readAscii
        <span class="apidocSignatureSpan">(view, offset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readAscii = function (view, offset, length) {
		if (view.byteLength &lt; offset + length) {
			return '';
		}
		var s = '';
		for (var i = 0; i &lt; length; i++) {
			s += String.fromCharCode(view.getUint8(offset + i));
		}

		return s;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	if (extendedHeader) {
		offset += getUint28(view, offset);
	}

	function readFrame(offset) {
		try {
			var id = utils.<span class="apidocCodeKeywordSpan">readAscii</span>(view, offset, 4);
			var size = getUint28(view, offset + 4);
			offset += 10; //+2 more for flags we don't care about

			if (id[0] !== 'T') {
				return {
					id: id,
					size: size + 10
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.audio-metadata.utils.readBytes" id="apidoc.element.audio-metadata.utils.readBytes">
        function <span class="apidocSignatureSpan">audio-metadata.utils.</span>readBytes
        <span class="apidocSignatureSpan">(view, offset, length, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBytes = function (view, offset, length, target) {
		if (offset + length &lt; 0) {
			return [];
		}

		var bytes = [];
		var max = Math.min(offset + length, view.byteLength);
		for (var i = offset; i &lt; max; i++) {
			var value = view.getUint8(i);
			bytes.push(value);
			if (target) {
				target.setUint8(i - offset, value);
			}
		}

		return bytes;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




var utils = require('./utils');

function checkMagicId3v1(view) {
	var id3Magic = utils.<span class="apidocCodeKeywordSpan">readBytes</span>(view, view.byteLength - 128, 3);
	//"TAG"
	return id3Magic[0] === 84 &amp;&amp; id3Magic[1] === 65 &amp;&amp; id3Magic[2] === 71;
}

module.exports = function(buffer) {
	//read last 128 bytes
	var view = utils.createView(buffer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.audio-metadata.utils.readUtf8" id="apidoc.element.audio-metadata.utils.readUtf8">
        function <span class="apidocSignatureSpan">audio-metadata.utils.</span>readUtf8
        <span class="apidocSignatureSpan">(view, offset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUtf8 = function (view, offset, length) {
		if (view.byteLength &lt; offset + length) {
			return '';
		}

		var buffer = view.buffer.slice(offset, offset + length);

		//http://stackoverflow.com/a/17192845 - convert byte array to UTF8 string
		var encodedString = String.fromCharCode.apply(null, new Uint8Array(buffer));
		return decodeURIComponent(escape(encodedString));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			var encoding = view.getUint8(offset),
				data = '';

			if (encoding &lt;= 3) {
				offset++;
				if (encoding === 3) {
					//UTF8 - null terminated
					data = utils.<span class="apidocCodeKeywordSpan">readUtf8</span>(view, offset, size - 1);
				} else {
					//ISO-8859-1, UTF-16, UTF-16BE
					//UTF-16 and UTF-16BE are $FF $00 terminated
					//ISO is null terminated

					//screw these encodings, read it as ascii
					data = utils.readAscii(view, offset, size - 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.audio-metadata.utils.trimNull" id="apidoc.element.audio-metadata.utils.trimNull">
        function <span class="apidocSignatureSpan">audio-metadata.utils.</span>trimNull
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trimNull = function (s) {
		return s.replace(/\u0000+$/, '');
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			} else {
				//no encoding info, read it as ascii
				data = utils.readAscii(view, offset, size);
			}

			//id3v2.4 is supposed to have encoding terminations, but sometimes
			//they don't? meh.
			data = utils.<span class="apidocCodeKeywordSpan">trimNull</span>(data);

			return {
				id: id,
				size: size + 10,
				content: data
			};
		} catch (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>